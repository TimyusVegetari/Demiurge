////////////////////////////////////////////////////////////
//
// This file is part of Demiurge.
// Copyright (C) 2011-2016 Acroute Anthony (ant110283@hotmail.fr)
//
// Demiurge is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 2 of the License, or
// (at your option) any later version.
//
// Demiurge is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Demiurge.  If not, see <http://www.gnu.org/licenses/>.
//
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// Description for Doxygen
////////////////////////////////////////////////////////////
/**
 * \file MeshesList.hpp
 * \brief Class to list 3D meshes.
 * \author Anthony Acroute
 * \version 0.1
 * \date 2016
 *
 */

#ifndef MESHESLIST_HPP__
#define MESHESLIST_HPP__

////////////////////////////////////////////////////////////
// Headers
////////////////////////////////////////////////////////////
#include "Mesh.hpp"
#include <map>

////////////////////////////////////////////////////////////
/// \brief Class to manage meshes of the game.
///
////////////////////////////////////////////////////////////
template <typename T>
class MeshesList {

    ////////////////////////////////////////////////////////////
    // Enumeration
    ////////////////////////////////////////////////////////////
    enum Error {
      NONE,
      UNCONSTRUCTED_OBJECT,
      OVERFLOWED_OBJECT
    };

  private :
    ////////////////////////////////////////////////////////////
    // Types
    ////////////////////////////////////////////////////////////
    typedef std::unique_ptr<T>        T_Ptr;  ///< std::unique_ptr of mesh.
    typedef std::pair<GLuint, T_Ptr>  Pair;   ///< std::pair of listed mesh pointers.

  protected :
    ////////////////////////////////////////////////////////////
    // Member data
    ////////////////////////////////////////////////////////////
    std::map<GLuint, T_Ptr>   m_mIndex; ///< Index of primitive 3d meshes pointers.
    GLuint  m_uiIdAccumulator;          ///< Greater identifiers generated since the begin
    GLuint  m_uiError;                  ///< Error value if an error arose.

  public :
    ////////////////////////////////////////////////////////////
    // Constructor(s)/Destructor
    ////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////
    /// \brief Default constructor.
    ///
    /// This constructor defines the meshes list.
    ///
    ////////////////////////////////////////////////////////////
    MeshesList          ( void );

    ////////////////////////////////////////////////////////////
    /// \brief Destructor.
    ///
    /// Cleans up all the internal resources used by the meshes list.
    ///
    ////////////////////////////////////////////////////////////
    virtual ~MeshesList ( void );

    ////////////////////////////////////////////////////////////
    // General methods
    ////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////
    /// \brief Add a mesh and return its identifier.
    ///
    /// \param poMesh   Pointer of the mesh.
    ///
    /// \return Identifier of the mesh.
    ///
    ////////////////////////////////////////////////////////////
    GLuint AddMesh ( T* poMesh );

    ////////////////////////////////////////////////////////////
    /// \brief Erase a mesh.
    ///
    /// \param uiMeshID   Identifier of the mesh.
    ///
    ////////////////////////////////////////////////////////////
    void Erase ( GLuint uiMeshID );

    ////////////////////////////////////////////////////////////
    // Accessor methods
    ////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////
    /// \brief Get if the list is empty.
    ///
    /// \return True if the list is empty, false else.
    ///
    ////////////////////////////////////////////////////////////
    GLboolean IsEmpty ( void );

    ////////////////////////////////////////////////////////////
    /// \brief Get the identified mesh.
    ///
    /// \param uiMeshID   Identifier of the mesh.
    ///
    /// \return Instance of the identified mesh.
    ///
    ////////////////////////////////////////////////////////////
    T& GetMesh ( GLuint uiMeshID );

    ////////////////////////////////////////////////////////////
    /// \brief Get the count of meshes.
    ///
    /// \return Count of meshes.
    ///
    ////////////////////////////////////////////////////////////
    GLuint GetMeshCount ( void );

    ////////////////////////////////////////////////////////////
    /// \brief Get the value of an error.
    ///
    /// \return Value of an error.
    ///
    ////////////////////////////////////////////////////////////
    GLuint CheckError ( void );

  private :
    ////////////////////////////////////////////////////////////
    // Internal methods
    ////////////////////////////////////////////////////////////

    ////////////////////////////////////////////////////////////
    /// \brief Check what type of error arose.
    ///
    /// \param uiMeshID   Identifier which make an error.
    ///
    ////////////////////////////////////////////////////////////
    void CheckIDError ( GLuint uiMeshID );
};

////////////////////////////////////////////////////////////
// Constructor(s)/Destructor
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
template <typename T>
MeshesList<T>::MeshesList ( void ) :
  m_mIndex          (),
  m_uiIdAccumulator (0),
  m_uiError         (Error::NONE)
{
  m_mIndex.insert (MeshesList::Pair (0, T_Ptr (new T ())));
}

////////////////////////////////////////////////////////////
template <typename T>
MeshesList<T>::~MeshesList ( void ) {
}

////////////////////////////////////////////////////////////
// General methods
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
template <typename T>
GLuint MeshesList<T>::AddMesh ( T* poMesh ) {
  m_uiIdAccumulator++;
  m_mIndex.insert (MeshesList::Pair (m_uiIdAccumulator, T_Ptr (poMesh)));

  return m_uiIdAccumulator;
}

////////////////////////////////////////////////////////////
template <typename T>
void MeshesList<T>::Erase ( GLuint uiMeshID ) {
  auto mFound = m_mIndex.find (uiMeshID);
  if (mFound == m_mIndex.end () || uiMeshID == 0) {
    CheckIDError (uiMeshID);
  } else {
    m_mIndex.erase (mFound);
  }
}

////////////////////////////////////////////////////////////
// Accessor methods
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
template <typename T>
GLboolean MeshesList<T>::IsEmpty ( void ) {
  return m_mIndex.size () <= 1;
}

////////////////////////////////////////////////////////////
template <typename T>
GLuint MeshesList<T>::CheckError ( void ) {
	return m_uiError;
}

////////////////////////////////////////////////////////////
template <typename T>
T& MeshesList<T>::GetMesh ( GLuint uiMeshID ) {
  auto mFound = m_mIndex.find (uiMeshID);
  if (mFound == m_mIndex.end () || uiMeshID == 0) {
    CheckIDError (uiMeshID);

    return (*m_mIndex[0]);
  }
  return (*mFound->second);
}

////////////////////////////////////////////////////////////
template <typename T>
GLuint MeshesList<T>::GetMeshCount ( void ) {
  return m_mIndex.size ()-1;
}

////////////////////////////////////////////////////////////
// Internal methods
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
template <typename T>
void MeshesList<T>::CheckIDError ( GLuint uiMeshID ) {
  if (uiMeshID > m_uiIdAccumulator) {
    m_uiIdAccumulator = uiMeshID;
    m_uiError = Error::OVERFLOWED_OBJECT;
  } else
    m_uiError = Error::UNCONSTRUCTED_OBJECT;
}

#endif // MESHESLIST_HPP__
